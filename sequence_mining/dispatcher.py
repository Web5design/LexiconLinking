""" This script interacts with the PSPAN file and project folders that are generated by the 
two ruby scripts.

It iteratively mines frequent sub-sequence patterns, extracts the items that fill the gaps of these sequences,
and then stores the items in a file.  This becomes a series of replacement rules: a CFG.
"""

import os
from collections import defaultdict

PSPAN_NAME = "lexbuild"
PROJECT_NAME = "step_names"
MIN_SET_SIZE = 3

# load psyco
try:
    import pscyo
    psyco.full()
except:
    print "No psyco"

def fnvhash(a): 
    """Fowler, Noll, Vo Hash function.  Used for hashing sequences""" 
    h = 2166136261 
    for i in a: 
        t = (h * 16777619) & 0xffffffffL 
        h = t ^ i 
    return h 
    
replaced = {}
def replace_with_ids(seq):
    return map(lambda x: (replaced.has_key(fnvhash([x])) and replaced[fnvhash([x])]) or x, seq)
        

def load_index_file():
    return [x.strip() for x in open("%s/%s.index" % (PROJECT_NAME,PROJECT_NAME), 'r').readlines()]

def extract_labeled_sequence_gaps(source_seq, test_seq):
    """ Takes two sequences and returns a dictionary of labeled gap values iff TEST_SEQ is a sub-sequence
    of SOURCE_SEQUENCE.
    
    extract_labeled_sequence_gaps([1,2,3,4],[1,2,5,7,3,6,4])    #=> {1:[5,7],4:[6]}
    extract_labeled_sequence_gaps([1,2,3,4],[1,1,1,2,3,4])      #=> {0:[1,1]}
    extract_labeled_sequence_gaps([1,2,3,4],[1,1,1,3])          #=> {}
    extract_labeled_sequence_gaps([1,2,3,4],[0,0,1,2,3,4,5,5])  #=> {}
    extract_labeled_sequence_gaps([1,5,1,6],[1,2,3,5,1,4,5,6])  #=> {0:[2,3],4:[4,5]}
    extract_labeled_sequence_gaps([1,5,1,6],[1,2,3,5,1,6])      #=> {0:[2,3]}
    """
    slot_vals = {} 
    tmp_gap = []
    prev_word_pos = 0   # the temp value used as a key for the gaps
    pos_in_seq = 0  # position of source_seq of test_seq's current match
    for i, el in enumerate(test_seq):
        if (len(source_seq)-pos_in_seq > len(test_seq)-i) or (pos_in_seq == len(source_seq)):
            return {} 
        if el == source_seq[pos_in_seq]:
            # match
            pos_in_seq += 1
            if pos_in_seq != 1 and len(tmp_gap) != 0:
                slot_vals[prev_word_pos] = tmp_gap
                tmp_gap = []
            prev_word_pos = i 
        else:
            tmp_gap.append(el)
    if pos_in_seq == len(source_seq):
        return slot_vals
    return {}

def run_pspan(top_k, maxgap, minlen, totalruns, indicies,seen_seq = []):
    # execute pspan
    fname = "%s/%s"
    os.system("rm %s.new_keys; touch %s.new_keys; rm %s.replace; touch %s.replace" % (fname,fname,fname,fname))
    os.system("./%s -P %s -v -K %i -G %i --length-min %i" % (PSPAN_NAME,PROJECT_NAME,top_k,maxgap,minlen))
    #--dspcacount 10  --length-min 3 -K 2   ; python interpret_stories.py")
    # load keys
    keynames = defaultdict(str)
    keynames[0] = "SPACE"
    max_key = 0
    kf = open('%s/%s.keys' % (PROJECT_NAME,PROJECT_NAME),'r')
    for line in kf.readlines():
        try:
            k,v = line.strip().split('\t')
            keynames[int(k)]=v
            if int(k) > max_key: max_key = int(k)
        except:
            print "Skipping line", line
            pass
    kf.close()
    kf2 = open('%s/%s.new_keys' % (PROJECT_NAME,PROJECT_NAME),'r')
    for line in kf2.readlines():
        items = line.strip().split('\t')
        key = int(items[0])
        for item in items:
            vals = map(lambda x: int(x), item.split())
            replaced[fnvhash(vals)] = key
    kf2.close()
    try: 
        rf = open('%s/%s.replace' % (PROJECT_NAME,PROJECT_NAME),'r')
    except IOError:
        # no file, create it.
        os.system('touch %s/%s.replace' % (PROJECT_NAME,PROJECT_NAME))
        rf = open('%s/%s.replace' % (PROJECT_NAME,PROJECT_NAME),'r')
    # parse sequences results
    sequences = map(lambda x:\
                    map(lambda z: int(z), x[2:-3].split(" ] [ ")), open('%s/%s.out' % (PROJECT_NAME,PROJECT_NAME),'r').readlines())
    sequences = filter(lambda x: seen_seq.count(fnvhash(x))== 0,sequences)



    patterns = defaultdict(list)
    for i, line in enumerate(open("%s/%s.proj" % (PROJECT_NAME,PROJECT_NAME),'r').readlines()):
        for j, v in enumerate(line.split()):
            # i = sequence file id ,  j = mined sequence id
            if v == "1":
                patterns[int(j)].append(int(i))

    all_sequence_matches = []
    # iterate through sequences  
    for seq_id, seq in enumerate(sequences): 
        # initialize default empty list
        all_sequence_matches.append(defaultdict(list))
        # open all approximated matches (from projectiion file, created by pspan)
        for seq_file_id in patterns[seq_id]:
            # read and parse the sequence into ids
            seq_file = open("%s" % indicies[seq_file_id],'r')
            test_seq = replace_with_ids(map(lambda x: int(x.strip()), seq_file.readlines()))
            # remove labeled gaps
            slot_vals = extract_labeled_sequence_gaps(seq, test_seq)
            # if it is a match
            if len(slot_vals.keys()) > 0:
                print "Match for seq %i " % (j), slot_vals
                # since we want to remember 0-length gaps, we must match existing keys and new keys separately
                new_keys = set(slot_vals.keys())-set(all_sequence_matches[seq_id].keys())
                # add old keys (and nil strings)
                for old_key in all_sequence_matches[seq_id].keys():
                    if slot_vals.has_key(old_key) and all_sequence_matches[seq_id][old_key].count(slot_vals[old_key]) == 0:
                        # this is a new value for a gap, add it:
                        all_sequence_matches[seq_id][old_key].append(slot_vals[old_key])
                    elif not slot_vals.has_key(old_key) and all_sequence_matches[seq_id][old_key].count([0]) == 0:
                        all_sequence_matches[seq_id][old_key].append([0])
                for new_key in new_keys:
                    if not all_sequence_matches[seq_id].has_key(new_key) or all_sequence_matches[seq_id][new_key].count(slot_vals[new_key]) == 0:

                        all_sequence_matches[seq_id][new_key].append(slot_vals[new_key])
            seq_file.close()

    # project sequence results 
    first = False
    max_len = 0
    mined_seq = 0
    rf = open('%s/%s.replace' %(PROJECT_NAME,PROJECT_NAME),'a')
    kf3 = open('%s/%s.new_keys' % (PROJECT_NAME,PROJECT_NAME),'a')
    to_replace = [] 
    for seq_i in xrange(0,len(sequences)):
        for key, gaps in sorted(all_sequence_matches[seq_i].items(), key = lambda x: len(x[1]), reverse=True):
            seq_description = "Sequence %i: %s " % (seq_i,' / '.join(map(lambda pos,x: keynames[x]+(key == pos and "/_" or ""), enumerate(sequences[seq_i]))))
            print "\t Set: ", ' / '.join(map(lambda x: ' '.join(map(lambda y: keynames[y], x)), gaps))
            print gaps, len(gaps)
            if len(gaps) >= max_len:
                max_len = len(gaps)
            if len(gaps) >= MIN_SET_SIZE:
                mined_seq += 1
                # hash seq, so you don't mine it again
                seen_seq.append(fnvhash(sequences[seq_i]))
                rf.write("#\n#"+seq_description+"\n")
                rf.write("#%0.2i0%i\t%s\n" % (seq_i,key,'\t'.join(map( lambda x: ' '.join(map(lambda y: keynames[y], x)), gaps))))
                rf.write("%0.2i0%i\t%s\n" % (seq_i,key,'\t'.join(map( lambda x: ' '.join(map(lambda y: str(y), x)), gaps))))
                max_key += 1
                new_key = max_key
                
                kf3.write("%i\t%s\n" % (new_key,'\t'.join(map(lambda y: ' '.join(map(lambda x: str(x),y)), gaps))))
                for val in gaps:
                    print "\tSlot %i => %s" % (key,' '.join(map(lambda x: keynames[x],val))), val
                    to_replace.append((val, new_key))
                    if keynames.has_key(new_key):
                        keynames[new_key] = ' '.join(map(lambda x: keynames[x],val)) 
                    else:
                        keynames[new_key] += ' '.join(map(lambda x: keynames[x],val)) 

    rf.close()
    kf3.close()
    to_replace = map(lambda x: (' '.join(map(lambda y: str(y), x[0])),str(x[1])), sorted(to_replace, key=lambda x: len(x[0])))
    # replace values in sequence files 
    for root, dirs, files in os.walk('%s/seq' % PROJECT_NAME):
        for fname in files:
            ofile = open('%s/seq/%s' % (PROJECT_NAME, fname), 'r')
            taint = False
            test_seq = ' '.join(map(lambda x: (x.strip()), ofile.readlines()))
            for (src,sink) in to_replace:
                if src in test_seq:
                     test_seq.replace(src,sink)
                     taint = True
            if taint:
                ofile.close()
                wfile =  open('%s/seq/%s' % (PROJECT_NAME, fname),'w')
                wfile.writelines('\n'.join(test_seq.split(" ")))
                wfile.close()

    print "Mined %i sequences in total" % mined_seq 
    return max_len, mined_seq 

def test0():
    print extract_labeled_sequence_gaps([1,2,3,4],[1,2,5,7,3,6,4])    #=> {1:[5,7],4:[6]}
    print extract_labeled_sequence_gaps([1,2,3,4],[1,1,1,2,3,4])      #=> {0:[1,1]}
    print extract_labeled_sequence_gaps([1,2,3,4],[1,1,1,3])          #=> {}
    print extract_labeled_sequence_gaps([1,2,3,4],[0,0,1,2,3,4,5,5])  #=> {}
    print extract_labeled_sequence_gaps([1,5,1,6],[1,2,3,5,1,4,5,6])  #=> {0:[2,3],4:[4,5]}
    print extract_labeled_sequence_gaps([1,5,1,6],[1,2,3,5,1,6])      #=> {0:[2,3]}


def test1():
    top_k =  80
    maxgap = 1 
    minlen = 5
    total_runs = 20
    indices = load_index_file()
    # TODO:  Only load files that are marked in the project file
    # don't depend on support from lexicon for replacing keys.  Do that instead within this program
    for run in xrange(0,total_runs):
        print "Run # %i" % run
        max_len, num_sequences = run_pspan(top_k, maxgap, minlen, total_runs, indices)
        if max_len < MIN_SET_SIZE and minlen == 2:
            print "DONE - goodbye!" 
            break
        elif max_len < MIN_SET_SIZE:
            if maxgap == 1:
                maxgap = 3 
            else:
                maxgap = 1
                minlen -= 1 # lower min length
    
    # write out new key
    file_index = load_index_file()
    all_input_sequences = open('%s/%s.all' % (PROJECT_NAME, PROJECT_NAME), 'r').readlines()
    all_output_sequences = open('%s/%s.map' % (PROJECT_NAME, PROJECT_NAME), 'w')
    for i,fname in enumerate(file_index):
        ofile = open(fname, 'r')
        out_seq = ' '.join(replace_with_ids(map(lambda x: (x.strip()), ofile.readlines())))
        all_output_sequences.write("%s\t\t%s\n" % (all_input_sequences[i].strip(), out_seq))
    all_output_sequences.close()

if __name__ == '__main__':
    test1()


