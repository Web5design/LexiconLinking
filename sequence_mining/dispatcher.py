""" This script interacts with the PSPAN file and project folders that are generated by the 
two ruby scripts.

It iteratively mines frequent sub-sequence patterns, extracts the items that fill the gaps of these sequences,
and then stores the items in a file.  This becomes a series of replacement rules: a CFG.
"""

import os
from collections import defaultdict

PSPAN_NAME = "lexbuild"
PROJECT_NAME = "step_names"

# load psyco
try:
    import pscyo
    psyco.full()
except:
    print "No psyco"


def load_index_file():
    return [x.strip() for x in open("%s/%s.index" % (PROJECT_NAME,PROJECT_NAME), 'r').readlines()]

def extract_labeled_sequence_gaps(source_seq, test_seq):
    """ Takes two sequences and returns a dictionary of labeled gap values iff TEST_SEQ is a sub-sequence
    of SOURCE_SEQUENCE.
    
        extract_labeled_sequence_gaps([1,2,3,4],[1,2,5,7,3,6,4]) #=> {2:[5,7],3:[6]}
        extract_labeled_sequence_gaps([1,2,3,4],[1,1,1,2,3,4])   #=> {1:[1,1]}
        extract_labeled_sequence_gaps([1,2,3,4],[1,1,1,3])       #=> {}
    """
    slot_vals = {} 
    tmp_gap = []
    prev_word = 0   # the temp value used as a key for the gaps
    pos_in_seq = 0  # position of source_seq of test_seq's current match
    for i, el in enumerate(test_seq):
        if (len(source_seq)-pos_in_seq > len(test_seq)-i) or (pos_in_seq == len(source_seq)):
            return {} 
        if el == source_seq[pos_in_seq]:
            # match
            pos_in_seq += 1
            if pos_in_seq != 1 and len(tmp_gap) != 0:
                slot_vals[prev_word] = tmp_gap
                tmp_gap = []
            prev_word = el
        else:
            tmp_gap.append(el)
    if pos_in_seq == len(source_seq):
        return slot_vals
    return {}

def run_pspan(top_k, maxgap, minlen, totalruns, indicies):
    # execute pspan
    #--dspcacount 10  --length-min 3 -K 2   ; python interpret_stories.py")
    os.system("./%s -P %s -v -K %i -G %i --length-min %i" % (PSPAN_NAME,PROJECT_NAME,top_k,maxgap,minlen))
    seen_seq = []
    # load keys
    keynames = {'0':'SPACE'}
    replaced = {}
    for line in open('%s/%s.keys' % (PROJECT_NAME,PROJECT_NAME),'r').readlines():
        try:
            k,v = line.strip().split('\t')
            keynames[int(k)]=v
        except:
            print "Skipping line", line
            pass
    try: 
        rf = open('%s/%s.replace' % (PROJECT_NAME,PROJECT_NAME),'r')
    except IOError:
        # no file, create it.
        os.system('touch %s/%s.replace' % (PROJECT_NAME,PROJECT_NAME))
        rf = open('%s/%s.replace' % (PROJECT_NAME,PROJECT_NAME),'r')

    replacements = rf.readlines()
    for line in replacements:
        if line[0] != '#':
            vals = [int(x) for x in line.strip().split('\t')]
            keynames[vals[0]] = 'seq-%i-%s' % (vals[0],'/'.join(map(lambda x: keynames[x], vals[1:])))
            to_replace = vals[1:]
            got = []
            for v in to_replace: 
                if replaced.has_key(v) and got.count(v) == 0:
                    to_replace.append(replaced[v])
                replaced[v] = vals[0]
                got.append(v)
    rf.close()
    # parse sequences results
    sequences = map(lambda x:\
                    map(lambda z: int(z), x[2:-3].split(" ] [ ")), open('%s/%s.out' % (PROJECT_NAME,PROJECT_NAME),'r').readlines())
    sequences = filter(lambda y: seen_seq.count('#'.join(map(lambda x: str(x),y)))== 0,sequences)

    def replace_with_ids(seq):
        return map(lambda x: (replaced.has_key(x) and replaced[x]) or x, seq)  
    
    patterns = defaultdict(list)
    for i, line in enumerate(open("%s/%s.proj" % (PROJECT_NAME,PROJECT_NAME),'r').readlines()):
        for j, v in enumerate(line.split()):
            # i = sequence file id ,  j = mined sequence id
            if v == "1":
                patterns[int(j)].append(int(i))

    all_sequence_matches = []
    # iterate through sequences  
    for seq_id, seq in enumerate(sequences): 
        # initialize default empty list
        all_sequence_matches.append(defaultdict(list))
        # open all approximated matches (from projectiion file, created by pspan)
        for seq_file_id in patterns[seq_id]:
            # read and parse the sequence into ids
            seq_file = open("%s" % indicies[seq_file_id],'r')
            test_seq = replace_with_ids(map(lambda x: int(x.strip()), seq_file.readlines()))
            # remove labeled gaps
            slot_vals = extract_labeled_sequence_gaps(seq, test_seq)
            # if it is a match
            if len(slot_vals.keys()) > 0:
                print "Match for seq %i " % (j), slot_vals
                # since we want to remember 0-length gaps, we must match existing keys and new keys separately
                new_keys = set(slot_vals.keys())-set(all_sequence_matches[seq_id].keys())
                # add old keys (and nil strings)
                for old_key in all_sequence_matches[seq_id].keys():
                    if slot_vals.has_key(old_key) and all_sequence_matches[seq_id][old_key].count(slot_vals[old_key]) == 0:
                        # this is a new value for a gap, add it:
                        all_sequence_matches[seq_id][old_key].append(slot_vals[old_key])
                    elif not slot_vals.has_key(old_key) and all_sequence_matches[seq_id][old_key].count([0]) == 0:
                        all_sequence_matches[seq_id][old_key].append([0])
                for new_key in new_keys:
                    if not all_sequence_matches[seq_id].has_key(new_key) or all_sequence_matches[seq_id][new_key].count(slot_vals[new_key]) == 0:
                        all_sequence_matches[seq_id][new_key].append(slot_vals[new_key])
            seq_file.close()

    # project sequence results 
    first = False
    rf = open('%s/%s.replace' %(PROJECT_NAME,PROJECT_NAME),'a')
    for seq_i in xrange(0,len(sequences)):
        seq_description = "Sequence %i: " % (seq_i), sequences[seq_i], ' / '.join(map(lambda x: keynames[x], sequences[seq_i]))
        for gaps in sorted(all_sequence_matches[seq_i].values(), key = lambda x: len(x), reverse=True):
            print "\t Set: ", ' / '.join(map(lambda x: ' '.join(map(lambda y: keynames[y], x)), gaps))
            print gaps, len(gaps)

    print "%i sequences in total" % (len(sequences))
if False:
    max_len = 0
    max_seq = 0

    for seq, matches in enumerate(all_sequence_matches): 
        print "Sequence %i " % seq , ' / '.join(map(lambda x: keynames[x], sequences[seq]))
        for slot_i, vals in matches.items():
            if lv >= max_len:
                max_len = lv 
                max_seq = (seq,slot_i)
            if lv >= 3:
                seen_seq.append('#'.join(map(lambda x: str(x),sequences[seq])))
                rf.write("#%0.3i%0.2i0%i\t%s\n" % (run,seq,slot_i,'\t'.join(map( lambda x: keynames[x[0]], vals))))
                items = map(lambda x: str(x[0]), vals)
                rf.write("%0.3i%0.2i0%i\t%s\n" % (run,seq,slot_i,'\t'.join(items)))
            for val in vals:
                print "\tSlot %i => %s" % (slot_i,' '.join(map(lambda x: keynames[x],val))), val
    rf.close()
    # make sure there's something here
    if max_len < 3 and minlen == 2:
        print "DONE - goodbye!" 
        #break
    if max_len < 3:
        minlen -= 1 # lower minimum length
        #continue


def test0():
    print extract_labeled_sequence_gaps([1,2,3,4],[1,2,5,7,3,6,4])    #=> {2:[5,7],3:[5]}
    print extract_labeled_sequence_gaps([1,2,3,4],[1,1,1,2,3,4])      #=> {1:[1,1]}
    print extract_labeled_sequence_gaps([1,2,3,4],[1,1,1,3])          #=> {}
    print extract_labeled_sequence_gaps([1,2,3,4],[0,0,1,2,3,4,5,5])  #=> {}


def test1():
    top_k =  50
    maxgap = 3 
    minlen = 4
    total_runs = 1
    indices = load_index_file()
    # TODO:  Only load files that are marked in the project file
    # don't depend on support from lexicon for replacing keys.  Do that instead within this program
    for run in xrange(0,total_runs):
        print "Run # %i" % run
        run_pspan(top_k, maxgap, minlen, total_runs, indices)




if __name__ == '__main__':
    test1()


